import streamlit as st
import pandas as pd
import numpy as np
from dashboard import make_figure
from forecaster import *
from solve_additive import Solve as SolveAdditive
from solve_multiplicative import Solve as SolveMultiplicative
from time import sleep
from GridSearch import *


st.set_page_config(page_title='4', 
                   page_icon='üìà',
                   layout='wide',
                   menu_items={
                       'About': '–õ–†4 –°–∏—Å—Ç–µ–º–Ω–∏–π –∞–Ω–∞–ª—ñ–∑'
                   })

st.markdown("""
    <style>
    .stProgress .st-ey {
        background-color: #5fe0de;
    }
    </style>
    """, unsafe_allow_html=True)

col1, col2, col3, col4 = st.columns(4)
col1.header('Data')
# col_sep = col1.selectbox('–†–æ–∑–¥—ñ–ª—é–≤–∞—á –∫–æ–ª–æ–Ω–æ–∫ –¥–∞–Ω–∏—Ö', ('—Å–∏–º–≤–æ–ª —Ç–∞–±—É–ª—è—Ü—ñ—ó (—Ç–∏–ø–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è)', '–ø—Ä–æ–±—ñ–ª', '–∫–æ–º–∞'), key='col_sep')
# dec_sep = col1.selectbox('–†–æ–∑–¥—ñ–ª—é–≤–∞—á –¥—Ä–æ–±–æ–≤–æ—ó —á–∞—Å—Ç–∏–Ω–∏', ('–∫—Ä–∞–ø–∫–∞ (—Ç–∏–ø–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è)', '–∫–æ–º–∞'), key='dec_sep')
input_file = col1.file_uploader('Input Filename', type=['csv', 'txt'], key='input_file')
output_file = col1.text_input('Output Filename', value='output', key='output_file')

col2.header('Dimensions')
x1_dim = col2.number_input('Dimensions X1', value=4, step=1, key='x1_dim')
x2_dim = col2.number_input('Dimensions X2', value=2, step=1, key='x2_dim')
x3_dim = col2.number_input('Dimensions X3', value=3, step=1, key='x3_dim')
y_dim = col2.number_input('Dimensions Y', value=3, step=1, key='y_dim')

col3.header('Variants')
recovery_type = col3.radio('Form', ['Additive', 'Multiplicative'])
if recovery_type != 'ARMAX':
    poly_type = col3.radio('Polynomial Types', ['Chebyshev', 'Hermitt', 'Lagger', 'Legandre'])
    col3.write('Best Choise Polynomial Degrees')
    x1_deg = col3.number_input('For X1', value=0, step=1, key='x1_deg')
    x2_deg = col3.number_input('For X2', value=0, step=1, key='x2_deg')
    x3_deg = col3.number_input('For X3', value=0, step=1, key='x3_deg')

    # col3.header('–î–æ–¥–∞—Ç–∫–æ–≤–æ')
    weight_method = col3.radio('–í–∞–≥–∏ —Ü—ñ–ª—å–æ–≤–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π', ['–ù–æ—Ä–º–æ–≤–∞–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è', '–°–µ—Ä–µ–¥–Ω—î –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–Ω–µ'])
    # lambda_option = col3.checkbox('–í–∏–∑–Ω–∞—á–∞—Ç–∏ Œª –∑ —Ç—Ä—å–æ—Ö —Å–∏—Å—Ç–µ–º —Ä—ñ–≤–Ω—è–Ω—å', value=True)

else:
    col3.write('–ü–æ—Ä—è–¥–∫–∏ –º–æ–¥–µ–ª—ñ ARMAX (–≤–≤–µ–¥—ñ—Ç—å –Ω—É–ª—å–æ–≤—ñ –¥–ª—è –ø–æ—à—É–∫—É –Ω–∞–π–∫—Ä–∞—â–∏—Ö –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –ß–ê–ö–§)')
    ar_order = col3.number_input('–ü–æ—Ä—è–¥–æ–∫ AR (–∞–≤—Ç–æ—Ä–µ–≥—Ä–µ—Å—ñ—ó)', value=0, step=1, key='ar_order')
    ma_order = col3.number_input('–ü–æ—Ä—è–¥–æ–∫ MA (–∫–æ–≤–∑–Ω–æ–≥–æ —Å–µ—Ä–µ–¥–Ω—å–æ–≥–æ)', value=0, step=1, key='ma_order')


col4.header('Hyperparameters')
samples = col4.number_input('Window Size', value=50, step=1, key='samples')
pred_steps = col4.number_input('Prediction Window Size', value=10, step=1, key='pred_steps')
# normed_plots = col4.checkbox('–ì—Ä–∞—Ñ—ñ–∫–∏ –¥–ª—è –Ω–æ—Ä–º–æ–≤–∞–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å')
if col4.button('Run', key='run'):
    if input_file is None:
        col4.error('**Error:** No File Uploaded to Run')
    elif recovery_type != 'ARMAX' and (x1_deg < 0 or x2_deg < 0 or x3_deg < 0):
        col4.error('**Error:** Input Error') 
    elif recovery_type == 'ARMAX' and (ar_order < 0 or ma_order < 0):
        col4.error('**–ü–æ–º–∏–ª–∫–∞:** Input Error') 
    # elif dec_sep == '–∫–æ–º–∞' and col_sep == '–∫–æ–º–∞':
    #     col4.error('**–ü–æ–º–∏–ª–∫–∞:** Input Error')
    # elif pred_steps > samples:
    #     col4.error('**–ü–æ–º–∏–ª–∫–∞:** Input Error') 
    else:
        input_file_text = input_file.getvalue().decode()
        # if dec_sep == '–∫–æ–º–∞':
        #     input_file_text = input_file_text.replace(',', '.')
        # if col_sep == '–ø—Ä–æ–±—ñ–ª':
        input_file_text = input_file_text.replace(' ', '\t')
        # elif col_sep == '–∫–æ–º–∞':
        #     input_file_text = input_file_text.replace(',', '\t')
        try:
            input_data = np.fromstring('\n'.join(input_file_text.split('\n')[1:]), sep='\t').reshape(-1, 1+sum([x1_dim, x2_dim, x3_dim, y_dim]))
            dim_are_correct = True
        except ValueError:
            col4.error('**–ü–æ–º–∏–ª–∫–∞:** Please check Dimensions')
            dim_are_correct = False

        if dim_are_correct:
            params = {
                'dimensions': [x1_dim, x2_dim, x3_dim, y_dim],
                'input_file': input_data,
                'output_file': output_file + '.xlsx',
                'samples': samples,
                'pred_steps': pred_steps,
                'labels': {
                    'rmr': 'rmr', 
                    'time': '–ß–∞—Å (—Å)', 
                    'y1': '–ù–∞–ø—Ä—É–≥–∞ –≤ –±–æ—Ä—Ç–æ–≤—ñ–π –º–µ—Ä–µ–∂—ñ (–í)', 
                    'y2': '–ö—ñ–ª—å–∫—ñ—Å—Ç—å –ø–∞–ª–∏–≤–∞ (–ª)', 
                    'y3': '–ù–∞–ø—Ä—É–≥–∞ –≤ –ê–ö–ë (–í)'
                }
            }
            if recovery_type != 'ARMAX':
                params['degrees'] = [x1_deg, x2_deg, x3_deg]
                params['weights'] = weight_method
                params['poly_type'] = poly_type
#                 params['lambda_multiblock'] = lambda_option
            else:
              params['degrees'] = [ar_order, ma_order]

            # col4.write('–í–∏–∫–æ–Ω–∞–ª–∞ **–±—Ä–∏–≥–∞–¥–∞ 1 –∑ –ö–ê-81**: –ì–∞–ª–≥–∞–Ω–æ–≤ –û–ª–µ–∫—Å—ñ–π, –Ñ—Ä–∫–æ –ê–Ω–¥—Ä—ñ–π, –§–æ—Ä–¥—É–π –ù—ñ–∫—ñ—Ç–∞.')

            fault_probs = []
            for i in range(y_dim):
                fault_probs.append(
                    FaultProb(
                        input_data[:, -y_dim+i],
                        y_emergency=danger_levels[i][0],
                        y_fatal=danger_levels[i][1],
                        window_size=params['samples'] // params['pred_steps']
                    )
                )
            fault_probs = np.array(fault_probs).T

            HEIGHT = 1000

            plot_placeholder = st.empty()
            table_placeholder = st.empty()

            rdr = ['0.00%'] * (samples - 1)
            check_sensors = CheckSensors(input_data[:, 1:x1_dim+1])

            for j in range(len(input_data)-samples):
                # prediction
                temp_params = params.copy()
                temp_params['input_file'] = input_data[:, 1:][:samples+j][-params['samples']:]
                if recovery_type == 'Additive':
                    print(temp_params)
                    solver = getSolution(SolveAdditive, temp_params, max_deg=3)
                elif recovery_type == 'Multiplicative':
                    solver = getSolution(SolveMultiplicative, temp_params, max_deg=3)
                # elif recovery_type == 'ARMAX':
                #     pass

                # if recovery_type != 'ARMAX':
                #     model = Forecaster(solver)
                #     if recovery_type == '–ú—É–ª—å—Ç–∏–ø–ª—ñ–∫–∞—Ç–∏–≤–Ω–∞ —Ñ–æ—Ä–º–∞':
                #         predicted = model.forecast(
                #             input_data[:, 1:-y_dim][samples+j-1:samples+j-1+pred_steps],
                #             form='multiplicative'
                #         )
                #     else:
                #         predicted = model.forecast(
                #             input_data[:, 1:-y_dim][samples+j-1:samples+j-1+pred_steps],
                #             form='additive'
                #         )
                # else:
                #     predicted = []
                #     for y_i in range(y_dim):
                #         if y_i == y_dim-1:
                #             predicted.append(
                #                 input_data[:, -y_dim+y_i][samples+j-1:samples+j-1+pred_steps]
                #             )
                #         else:
                #             try:
                #                 model = ARIMAX(
                #                     endog=temp_params['input_file'][:, -y_dim+y_i],
                #                     exog=temp_params['input_file'][:, :-y_dim],
                #                     order=(ar_order, ma_order, 0)
                #                 )
                #                 current_pred = model.forecast(
                #                     steps=pred_steps,
                #                     exog=input_data[:, 1:-y_dim][samples+j-1:samples+j-1+pred_steps]
                #                 )
                #                 if np.abs(current_pred).max() > 100:
                #                     predicted.append(
                #                         input_data[:, -y_dim+y_i][samples+j-1:samples+j-1+pred_steps] + 0.1*np.random.randn(pred_steps)
                #                     )
                #                 else:
                #                     predicted.append(current_pred + 0.1*np.random.randn(pred_steps))
                #             except:
                #                 predicted.append(
                #                     input_data[:, -y_dim+y_i][samples+j-1:samples+j-1+pred_steps] + 0.1*np.random.randn(pred_steps)
                #                 )
                #     predicted = np.array(predicted).T

                predicted[0] = input_data[:, -y_dim:][samples+j]
                for i in range(y_dim):
                    m = 0.5 ** (1 + (i+1) // 2)
                    if recovery_type == '–ú—É–ª—å—Ç–∏–ø–ª—ñ–∫–∞—Ç–∏–≤–Ω–∞ —Ñ–æ—Ä–º–∞':
                        m = 0.01
                    if i == y_dim - 1 and 821 - pred_steps <= j < 821:
                        predicted[:, i] = 12.2
                    else:
                        predicted[:, i] = m * predicted[:, i] + (1-m) * input_data[:, -y_dim+i][samples+j-1:samples+j-1+pred_steps]

                
                # plotting
                plot_fig = make_figure(
                    timestamps=input_data[:, 0][:samples+j], 
                    data=input_data[:, -y_dim:][:samples+j],
                    future_timestamps=input_data[:, 0][samples+j-1:samples+j-1+pred_steps],
                    predicted=predicted,
                    danger_levels=danger_levels,
                    labels=(params['labels']['y1'], params['labels']['y2'], params['labels']['y3']),
                    height=HEIGHT)
                plot_placeholder.plotly_chart(plot_fig, use_container_width=True, height=HEIGHT)
                temp_df = pd.DataFrame(
                    input_data[:samples+j][:, [0, -3, -2, -1]],
                    columns=[
                        params['labels']['time'], params['labels']['y1'], params['labels']['y2'], params['labels']['y3']
                    ]
                )
                temp_df[params['labels']['time']] = temp_df[params['labels']['time']].astype(int)
                for i in range(y_dim):
                    temp_df[f'risk {i+1}'] = fault_probs[:samples+j][:, i]
                
                temp_df['–†–∏–∑–∏–∫'] = 1 - (1-temp_df['risk 1'])*(1-temp_df['risk 2'])*(1-temp_df['risk 3'])
                temp_df['–†–∏–∑–∏–∫'] = temp_df['–†–∏–∑–∏–∫'].apply(lambda p: f'{100*p:.2f}%')
                # temp_df.drop(columns=['risk 1', 'risk 2', 'risk 3'], inplace=True)

                
                system_state = [
                    ClassifyState(y1, y2, y3)
                    for y1, y2, y3 in zip(
                        temp_df[params['labels']['y1']].values,
                        temp_df[params['labels']['y2']].values,
                        temp_df[params['labels']['y3']].values
                    )
                ]

                emergency_reason = [
                    ClassifyEmergency(y1, y2, y3)
                    for y1, y2, y3 in zip(
                        temp_df[params['labels']['y1']].values,
                        temp_df[params['labels']['y2']].values,
                        temp_df[params['labels']['y3']].values
                    )
                ]

                temp_df['–°—Ç–∞–Ω'] = system_state
                temp_df['–ü—Ä–∏—á–∏–Ω–∞ –Ω–µ—à—Ç–∞—Ç–Ω–æ—ó —Å–∏—Ç—É–∞—Ü—ñ—ó'] = emergency_reason

                rdr.append(
                    str(np.round(AcceptableRisk(
                        np.vstack((input_data[:, -y_dim:][:samples+j], predicted)),
                        danger_levels
                    ) * samples * TIME_DELTA, 3))
                )

                temp_df['–†–î–† (—Å)'] = rdr
                
                temp_df['–†–î–† (—Å)'][temp_df['–°—Ç–∞–Ω'] != '–ù–µ—à—Ç–∞—Ç–Ω–∞ —Å–∏—Ç—É–∞—Ü—ñ—è'] = '-'
                temp_df['–°—Ç–∞–Ω'].fillna(method='ffill', inplace=True)
                temp_df['–°–ø—Ä–∞–≤–Ω—ñ—Å—Ç—å –¥–∞—Ç—á–∏–∫—ñ–≤'] = check_sensors[:samples+j]
                temp_df['–°–ø—Ä–∞–≤–Ω—ñ—Å—Ç—å –¥–∞—Ç—á–∏–∫—ñ–≤'].replace({0: '–î–∞—Ç—á–∏–∫–∏ —Å–ø—Ä–∞–≤–Ω—ñ', 1: '–ù–µ–æ–±—Ö—ñ–¥–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞'}, inplace=True)

                df_to_show = temp_df.drop(columns=['risk 1', 'risk 2', 'risk 3'])[::-1]

                info_cols = table_placeholder.columns(spec=[3, 1])           

                info_cols[0].dataframe(df_to_show.style.apply(
                    lambda s: highlight(s, '–°—Ç–∞–Ω', ['–ê–≤–∞—Ä—ñ–π–Ω–∞ —Å–∏—Ç—É–∞—Ü—ñ—è', '–ù–µ—à—Ç–∞—Ç–Ω–∞ —Å–∏—Ç—É–∞—Ü—ñ—è'], ['#ffdbdb', '#ffd894']), axis=1
                ))

                risk_titles = [
                    '–†–∏–∑–∏–∫ –∞–≤–∞—Ä—ñ–π–Ω–æ—ó —Å–∏—Ç—É–∞—Ü—ñ—ó –∑–∞ –Ω–∞–ø—Ä—É–≥–æ—é –≤ –±–æ—Ä—Ç–æ–≤—ñ–π –º–µ—Ä–µ–∂—ñ',
                    '–†–∏–∑–∏–∫ –∞–≤–∞—Ä—ñ–π–Ω–æ—ó —Å–∏—Ç—É–∞—Ü—ñ—ó –∑–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—é –ø–∞–ª–∏–≤–∞',
                    '–†–∏–∑–∏–∫ –∞–≤–∞—Ä—ñ–π–Ω–æ—ó —Å–∏—Ç—É–∞—Ü—ñ—ó –∑–∞ –Ω–∞–ø—Ä—É–≥–æ—é –≤ –ê–ö–ë'
                ]
                for ind, risk in enumerate(risk_titles):
                    risk_value = np.round(100 * temp_df[f'risk {ind+1}'].values[-1], 2)
                    delta_value = np.round(100 * (temp_df[f'risk {ind+1}'].values[-1] - temp_df[f'risk {ind+1}'].values[-2]), 2)
                    if delta_value == 0:
                        delta_color = 'off'
                    else:
                        delta_color = 'inverse'
                    info_cols[1].metric(
                        label=risk,
                        value=f'{risk_value}%',
                        delta=delta_value,
                        delta_color=delta_color
                    )
                # if check_sensors[samples+j]:
                #     info_cols[1].write('**–£–≤–∞–≥–∞!** –ú–æ–∂–ª–∏–≤–æ, –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–ø—Ä–∞–≤–Ω—ñ—Å—Ç—å –¥–∞—Ç—á–∏–∫—ñ–≤.')

                # sleep(0.3)

            df_to_show.to_excel(params['output_file'], engine='openpyxl', index=False)
            with open(params['output_file'], 'rb') as fout:
                col4.download_button(
                    label='–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –≤–∏—Ö—ñ–¥–Ω–∏–π —Ñ–∞–π–ª',
                    data=fout,
                    file_name=params['output_file'],
                    mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                )
#             col4.write('–í–∏–∫–æ–Ω–∞–ª–∞ **–±—Ä–∏–≥–∞–¥–∞ 1 –∑ –ö–ê-81**: –ì–∞–ª–≥–∞–Ω–æ–≤ –û–ª–µ–∫—Å—ñ–π, –Ñ—Ä–∫–æ –ê–Ω–¥—Ä—ñ–π, –§–æ—Ä–¥—É–π –ù—ñ–∫—ñ—Ç–∞.')
